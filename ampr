#!/bin/bash

#
#Automatic Multipath Route: keep any number of multipath routes with any number of nexthop routers.
# Copyright (C) 2013 Diego Augusto Molina
#
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU
# General Public Licence Version 2 as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public Licence for more details.
#
# You should have recieved a copy of the GNU General Public Licence along with this program; if not,
# write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
# USA.
#

####################################################################################################
####################################################################################################
####################################################################################################

  # Strictness
set -o posix;
set -u;
set +H;
set +e;

  # Include the code of the "pingmon" function. Would be fatal if couldn't
set -e;
source "$(dirname "$0")/libpingmon.sh";
set +e;

##### Declarations #################################################################################

declare -ar VARS_OVERWRITE=( NWEIGHT SWEIGHT INIT PINGMON_OPTS REST PRETEND );
declare -a line ROUTES ROUTE_PATHS PATHS;
declare -i r=-1 p=-1 in_def_head=0 INIT=1 NWEIGHT=5 SWEIGHT=3 PRETEND=0;
declare v AMPR_REPLY CONFIG_FILE REST=1;
declare PINGMON_OPTS="-C 5 -F 1 -k 2 -K 2 -q 0 -U 10 -x 120 -X 6" PIDS="";
declare -r AMPR_TRAPS="RETURN SIGTERM SIGINT SIGHUP";

##### Functions ####################################################################################

hlp(){
  echo "
Automatic Multipath Route: keep any number of multipath routes with any number of nexthop routers.
  Copyright (C) 2013 Diego Augusto Molina

  This program is free software; you can redistribute it and/or modify it under the terms of the GNU
  General Public Licence Version 2 as published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
  even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  General Public Licence for more details.

  You should have recieved a copy of the GNU General Public Licence along with this program; if not,
  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
  USA.

Usage:
  1) Get this help:
    ${0}
  2) Do AMPR:
    ${0} CONFIG_FILE
  3) Only execute the 'pingmon' function (with no extra arguments will give you help):
    ${0} pingmon [pingmon args]

This program must be run as root.

What does the program do:
  The program relies on specific routes for hosts to determine the availability of a path. If
  INIT is non zero, the program will make these routes for you. Basically what it will do is to
  create a unicast route that matches a single host usning a specific nexthop router. Then, it
  will use the 'pingmon' function to ping that host. That ICMP request will be sent to the
  remote host through the nexthop router due to the route we had created previously. The 'pingmon'
  function will then tell the main program when the connection to the remote host is 'acceptable',
  which will cause the main program to add the nexthop router to the multipath route. The 'pingmon'
  function may consider the connection 'acceptable, but with high latency', in which case the
  nexthop router is weighted accordingly in the multipath route to favour other paths. When the
  'pingmon' function determines there is no connection available the path will be brought down,
  without affecting the other paths, and flushing all the routes that were cached through that
  nextop router. When no path is available, the entire route is deleted.

Configuration file format:
  The file is a regular INI file. The special section [general] serves to declare default values.
  Comments start with a hash sign (#) and occupy the rest of the line. White space is trimmed from
  lines and comments are removed when parsing.

  The fllowing are the values that can be declared in the [general] section:
  * NWEIGHT: default weight for normal paths. The default value of this configuration is '$NWEIGHT'.
  * SWEIGHT: weight for high latency paths. The default value of this configuration is '$SWEIGHT'.
  * INIT: wether to initialize the special routes for each remote host behind the nexthop routers
    (see later). Set to non zero to enable. The default value of this configuration is '$INIT'.
  * PINGMON_OPTS: default options to pass to 'pingmon' function, which is the function that performs
    monitoring. To see how 'pingmon' can be used execute the following:
      ${0} pingmon
    The default value of this configuration is:
      ${PINGMON_OPTS}
  * REST: sleep for this number of seconds after completion of each group of operations. This value
    will be passed to 'sleep'. The default value of this configuration is '$REST'.
  * PRETEND: if non zero, will run the whole program but will write to stdout the 'ip' commands
    instead of actually executing them. The default value of this configuration is '$PRETEND'.
  You can declare the [general] section as many times you want: each variable declaration
  overwrites the previous one.
  Any other section will be interpreted as a multipath route definition, and each line of the
  contents of that section a path definition of that multipath route. The header itself serves
  as the starting arguments to 'ip route replace' or 'ip route delete'. So you may specify any
  arguments you want for the route in that header, like 'table my_tab', 'metric 2'. The only one
  that cannot be missing is the 'to' argument (for obvious reasons). Examples:
    [default]
    [192.168.2.0/24 scope global src 192.168.1.1 metric 10]

  The rest of the arguments to the 'ip' command, namely the nexthops, will be added dynamically
  when they are determined to be available. Each nexthop definition is a white space separated
  list of items in the same line. Each line is supposed to have at least three items. The items
  will be interpreted in the following order:
  1) IP address of the remote host to monitor through this path.
  2) Network interface name.
  3) Nexthop router.
  4) Normal weight and small weight (for high latencies) for this specific path, separated by a
    comma. If only one value is given it will be interpreted as the normal weight.
  5) The rest of the items will be passed 'as-is' to the 'pingmon' function, so that you can
    make any particular configuration for a path.
  Examples:
    8.8.8.8 eth0 10.0.0.2
    4.4.4.4 eth1 10.0.0.3 1,2

  IMPORTANT NOTE: no validation is done on the arguments passed to the 'ip' command. Correctness
  relies entirely on your veification.
" >&2;
  exit 0;
};

##### Parse command line arguments #################################################################

if [ $# -eq 0 ]; then
  hlp;
fi;

if [ "$1" = "pingmon" ]; then
  shift;
  if [ $# -gt 0 ]; then
    pingmon "$@";
  else
    pingmon;
  fi;
  exit $?;
fi;

if [ $# -ne 1 ]; then
  echo "ERROR: too many arguments." >&2;
  hlp;

elif [ ! -r "$1" ] || [ ! -f "$1" ]; then
  echo "ERROR: can't open regular file '$1' for reading." >&2;
  hlp;

elif [ $EUID -ne 0 ]; then
  echo "ERROR: not running as root." >&2;
  hlp;
fi;

readonly CONFIG_FILE="$1";

  ## Read config file
while read AMPR_REPLY; do
    # If it's a header
  if [ "${AMPR_REPLY:0:1}" = "[" ]; then
    if [ "$AMPR_REPLY" = "[general]" ]; then
      in_def_head=1;
    else
      in_def_head=0;
      r=${#ROUTES[@]};
      ROUTES[$r]="${AMPR_REPLY:1:${#AMPR_REPLY}-2}";
    fi;

    # If it's a variable
  elif [ $in_def_head -eq 1 ]; then
    for v in "${VARS_OVERWRITE[@]}"; do
      if [ "$v" = "${AMPR_REPLY/=*}" ]; then
        eval "${AMPR_REPLY/=*}"="'${AMPR_REPLY#*=}'";
        break;
      fi;
    done;

    # If it's a path
  else
    if [ $r -eq -1 ]; then
      echo "Error parsing config file on line '$AMPR_REPLY'. No previus section declared." >&2;
      exit 1;
    fi;

    p=${#PATHS[@]};
    ROUTE_PATHS[$r]="${ROUTE_PATHS[$r]:-} $p";
    line=( $AMPR_REPLY );
    if [ ${#line[@]} -gt 3 ]; then
      PATHS[$p]="$AMPR_REPLY";
    elif [ ${#line[@]} -gt 2 ]; then
      PATHS[$p]="$AMPR_REPLY $NWEIGHT,$SWEIGHT";
    else
      echo "Error parsing config file on line '$AMPR_REPLY'." >&2;
      exit 1;
    fi;
  fi;
done <<< "$(
    ## Delete comments and empty lines and make all lower case
  sed '/^\s*\(#.*\)*$/d; s/^\s*//g' "${CONFIG_FILE}"
)";

if [ $PRETEND -ne 0 ]; then
  alias ip='echo ip';
fi;

  # Protect variables in this context. Two things are infinite...
readonly ROUTES ROUTE_PATHS PATHS PINGMON_OPTS NWEIGHT SWEIGHT INIT REST;

##### Initialize routes for the paths ##############################################################

if [ $INIT -ne 0 ]; then
  for v in "${PATHS[@]}"; do
    line=( $v );
    ip route replace ${line[0]}/32 dev ${line[1]} via ${line[2]};
  done;
fi;

##### Execute the actions ##########################################################################

for r in "${!ROUTE_PATHS[@]}"; do
  if [ -z "${r:-}" ]; then
    continue;
  fi;
  for p in ${ROUTE_PATHS[$r]}; do

    line=( ${PATHS[$p]} );
    pingmon $PINGMON_OPTS ${line[@]:4} ${line[0]} 2>&1 1> /dev/null | {
      while read AMPR_REPLY; do
          # Determine signal type and forward it with the route and the path
        case "${AMPR_REPLY:0:13}" in
          "### ERROR #0 ")
            echo OK $r $p $(date '+%s %Y-%m-%d %H:%M:%S') "Err#"0;
            ;;

          "### ERROR #3 ")
            echo SLOW $r $p $(date '+%s %Y-%m-%d %H:%M:%S') "Err#"3;
            ;;

          "### ERROR #"*)
            echo FAIL $r $p $(date '+%s %Y-%m-%d %H:%M:%S') "Err#"${AMPR_REPLY:11:2};
            ;;

          *)
            # There might be other stuff in stderr, and nothing should be done for that
            true;
            ;;
        esac;
      done;
    } &
    PIDS="$PIDS $!";

      # Make sure we kill every process we started
    trap - $AMPR_TRAPS;
    trap "kill $PIDS &" $AMPR_TRAPS;

  done;
done | {
    ## Initialize
  declare -a paths=() reply=();
  declare weight;

  while read AMPR_REPLY; do

    if [ $PRETEND -ne 0 ]; then
      echo -e "\n*** EVENT TRIGGERED: $AMPR_REPLY";
    fi;

    reply=( $AMPR_REPLY );
    case "${reply[0]}" in
      FAIL)
          ## If this connection has already failed (probably with another error) skip the signal.
          # Another posibility is that it is the first time and 'paths' is still empty
        if [ -z "${paths[${reply[2]}]:-}" ]; then
          if [ $PRETEND -ne 0 ]; then
            echo "(SKIPPED)";
          fi;
          continue;
        fi;
        unset paths[${reply[2]}];
        ;;

      SLOW)
        line=( ${PATHS[${reply[2]}]} );
        weight=$SWEIGHT;
        if [ -n "${line[3]:-}" ] && [ "${line[3]#*,}" != "${line[3]}" ]; then
          weight="${line[3]#*,}";
        fi;
        line[3]=$weight;
        paths[${reply[2]}]="${line[*]}";
        ;;

      OK)
        line=( ${PATHS[${reply[2]}]} );
        weight=$NWEIGHT;
        if [ -n "${line[3]:-}" ]; then
          weight="${line[3]%,*}";
        fi;
        line[3]=$weight;
        paths[${reply[2]}]="${line[*]}";
        ;;

      *)
        echo "WTF is ${reply[0]}!!!" >&2;
        continue;
        ;;
    esac;

      # Iterate over the available paths to determine all nexthop routers
    v="";
    r=0;
    for p in ${ROUTE_PATHS[${reply[1]}]}; do
      if [ -n "${paths[$p]:-}" ]; then
        line=( ${paths[$p]} );
        let r=1+$r;
        if [ $r -gt 1 ]; then
          v="$v nexthop";
        fi;
        v="$v dev ${line[1]} via ${line[2]} weight ${line[3]}";
      fi;
    done;

      # Update the route. Will depend on how many nexthop routers are available
    if [ $r -gt 1 ]; then
      ip route replace ${ROUTES[${reply[1]}]} nexthop $v;

    elif [ $r -gt 0 ]; then
      ip route replace ${ROUTES[${reply[1]}]} $v;

    else
      ip route delete ${ROUTES[${reply[1]}]};
    fi;

      # Flush cached routes
    if [ "${reply[0]}" = "FAIL" ]; then
      line=( ${PATHS[${reply[2]}]} );
      ip route flush cached dev ${line[1]} via ${line[2]};
    fi;

      # Take it easy
    sleep $REST;

  done;
};

